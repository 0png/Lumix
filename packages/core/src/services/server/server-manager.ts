// ServerManager - 伺服器實例管理服務
// 負責建立、管理、啟動/停止 Minecraft 伺服器實例

import { spawn, type ChildProcess } from 'node:child_process';
import { EventEmitter } from 'node:events';
import { promises as fs } from 'node:fs';
import path from 'node:path';
import { v4 as uuidv4 } from 'uuid';
import type {
  ServerInstance,
  InstanceConfig,
  CreateInstanceConfig,
  ServerStatus,
  LogEntry,
  LogLevel,
} from '../../models/types';
import { configManager } from '../config-manager';
import { getInstancesDir, ensureDir, removeDir } from '../../utils/file-utils';
import { parseLogLine as parseLog, isServerStartedMessage } from './log-parser';

// ============================================================================
// Types
// ============================================================================

export interface ServerManagerEvents {
  'status-changed': (serverId: string, status: ServerStatus) => void;
  'log': (serverId: string, entry: LogEntry) => void;
  'exit': (serverId: string, code: number | null, signal: string | null) => void;
}

interface RunningServer {
  process: ChildProcess;
  status: ServerStatus;
  logs: LogEntry[];
}

// ============================================================================
// ServerManager Class
// ============================================================================

export class ServerManager extends EventEmitter {
  private runningServers: Map<string, RunningServer> = new Map();
  private readonly maxLogEntries = 1000;

  constructor() {
    super();
  }

  // ==========================================================================
  // Instance Management (11.1)
  // ==========================================================================

  async createInstance(config: CreateInstanceConfig): Promise<ServerInstance> {
    const id = uuidv4();
    const instanceDir = path.join(getInstancesDir(), id);

    await this.createDirectoryStructure(instanceDir);
    await this.generateEula(instanceDir);

    const instanceConfig: InstanceConfig = {
      id,
      name: config.name,
      coreType: config.coreType,
      mcVersion: config.mcVersion,
      javaPath: '',
      ramMin: config.ramMin ?? 1024,
      ramMax: config.ramMax ?? 4096,
      jvmArgs: config.jvmArgs ?? [],
      createdAt: new Date().toISOString(),
    };

    await configManager.saveInstanceConfig(instanceConfig);
    return this.configToInstance(instanceConfig, instanceDir);
  }

  private async createDirectoryStructure(instanceDir: string): Promise<void> {
    await ensureDir(instanceDir);
    const subDirs = ['plugins', 'mods', 'world', 'logs', 'config'];
    for (const dir of subDirs) {
      await ensureDir(path.join(instanceDir, dir));
    }
  }

  private async generateEula(instanceDir: string): Promise<void> {
    const eulaPath = path.join(instanceDir, 'eula.txt');
    const content = `# By changing the setting below to TRUE you are indicating your agreement to our EULA (https://aka.ms/MinecraftEULA).
# Generated by Lumix Launcher
eula=true
`;
    await fs.writeFile(eulaPath, content, 'utf-8');
  }

  private configToInstance(config: InstanceConfig, directory: string): ServerInstance {
    const running = this.runningServers.get(config.id);
    return {
      id: config.id,
      name: config.name,
      coreType: config.coreType,
      mcVersion: config.mcVersion,
      javaPath: config.javaPath,
      ramMin: config.ramMin,
      ramMax: config.ramMax,
      jvmArgs: config.jvmArgs,
      directory,
      status: running?.status ?? 'stopped',
      createdAt: new Date(config.createdAt),
      lastStartedAt: config.lastStartedAt ? new Date(config.lastStartedAt) : undefined,
    };
  }

  // ==========================================================================
  // CRUD Operations (11.3)
  // ==========================================================================

  async getAllInstances(): Promise<ServerInstance[]> {
    const configs = await configManager.getAllInstanceConfigs();
    return configs.map((config) => {
      const directory = configManager.getInstanceDir(config.id);
      return this.configToInstance(config, directory);
    });
  }

  async getInstance(id: string): Promise<ServerInstance | null> {
    const config = await configManager.getInstanceConfig(id);
    if (!config) return null;
    const directory = configManager.getInstanceDir(id);
    return this.configToInstance(config, directory);
  }

  async updateInstance(
    id: string,
    updates: Partial<Omit<InstanceConfig, 'id' | 'createdAt'>>
  ): Promise<ServerInstance | null> {
    const config = await configManager.getInstanceConfig(id);
    if (!config) return null;

    const updatedConfig: InstanceConfig = { ...config, ...updates };
    await configManager.saveInstanceConfig(updatedConfig);
    const directory = configManager.getInstanceDir(id);
    return this.configToInstance(updatedConfig, directory);
  }

  async deleteInstance(id: string): Promise<boolean> {
    const exists = await configManager.instanceExists(id);
    if (!exists) return false;

    if (this.runningServers.has(id)) {
      await this.stopServer(id);
    }

    const directory = configManager.getInstanceDir(id);
    await removeDir(directory);
    configManager.removeInstanceFromCache(id);
    return true;
  }

  // ==========================================================================
  // Lifecycle Control (11.5)
  // ==========================================================================

  async startServer(id: string): Promise<boolean> {
    const instance = await this.getInstance(id);
    if (!instance || this.runningServers.has(id)) return false;

    if (!instance.javaPath) throw new Error('Java path not configured');

    const serverJar = await this.findServerJar(instance.directory);
    if (!serverJar) throw new Error('Server JAR not found');

    const jvmArgs = [
      `-Xms${instance.ramMin}M`,
      `-Xmx${instance.ramMax}M`,
      ...instance.jvmArgs,
      '-jar',
      serverJar,
      'nogui',
    ];

    this.setServerStatus(id, 'starting');

    const process = spawn(instance.javaPath, jvmArgs, {
      cwd: instance.directory,
      stdio: ['pipe', 'pipe', 'pipe'],
    });

    this.runningServers.set(id, { process, status: 'starting', logs: [] });
    this.setupProcessListeners(id, process);

    await this.updateInstance(id, { lastStartedAt: new Date().toISOString() });
    return true;
  }

  async stopServer(id: string, timeout = 30000): Promise<boolean> {
    const running = this.runningServers.get(id);
    if (!running) return false;

    this.setServerStatus(id, 'stopping');
    running.process.stdin?.write('stop\n');

    return new Promise((resolve) => {
      const timeoutId = setTimeout(() => {
        this.forceKillServer(id);
        resolve(true);
      }, timeout);

      running.process.once('exit', () => {
        clearTimeout(timeoutId);
        resolve(true);
      });
    });
  }

  forceKillServer(id: string): boolean {
    const running = this.runningServers.get(id);
    if (!running) return false;
    running.process.kill('SIGKILL');
    return true;
  }

  sendCommand(id: string, command: string): boolean {
    const running = this.runningServers.get(id);
    if (!running || running.status !== 'running') return false;
    running.process.stdin?.write(`${command}\n`);
    return true;
  }

  private async findServerJar(directory: string): Promise<string | null> {
    try {
      const files = await fs.readdir(directory);
      const jarFile = files.find(
        (f) =>
          f.endsWith('.jar') &&
          (f.includes('server') || f.includes('paper') || f.includes('fabric') || f.includes('forge'))
      );
      return jarFile ? path.join(directory, jarFile) : null;
    } catch {
      return null;
    }
  }


  // ==========================================================================
  // Log Streaming (11.6)
  // ==========================================================================

  private setupProcessListeners(id: string, process: ChildProcess): void {
    process.stdout?.on('data', (data: Buffer) => {
      this.processLogData(id, data.toString());
    });

    process.stderr?.on('data', (data: Buffer) => {
      this.processLogData(id, data.toString(), 'error');
    });

    process.on('exit', (code, signal) => {
      this.handleProcessExit(id, code, signal);
    });

    process.on('error', (error) => {
      this.addLogEntry(id, {
        timestamp: new Date(),
        level: 'error',
        message: `Process error: ${error.message}`,
      });
    });
  }

  private processLogData(id: string, data: string, defaultLevel: LogLevel = 'info'): void {
    const lines = data.split('\n').filter((line) => line.trim());

    for (const line of lines) {
      const entry = this.parseLogLine(line, defaultLevel);
      this.addLogEntry(id, entry);

      if (isServerStartedMessage(line)) {
        this.setServerStatus(id, 'running');
      }
    }
  }

  /** 解析日誌行（公開方法供測試使用） */
  parseLogLine(line: string, defaultLevel: LogLevel = 'info'): LogEntry {
    return parseLog(line, defaultLevel);
  }

  private addLogEntry(id: string, entry: LogEntry): void {
    const running = this.runningServers.get(id);
    if (running) {
      running.logs.push(entry);
      if (running.logs.length > this.maxLogEntries) {
        running.logs.shift();
      }
    }
    this.emit('log', id, entry);
  }

  getLogs(id: string, limit?: number): LogEntry[] {
    const running = this.runningServers.get(id);
    if (!running) return [];
    if (limit && limit < running.logs.length) {
      return running.logs.slice(-limit);
    }
    return [...running.logs];
  }

  clearLogs(id: string): void {
    const running = this.runningServers.get(id);
    if (running) running.logs = [];
  }

  // ==========================================================================
  // Status Notification (11.8)
  // ==========================================================================

  private setServerStatus(id: string, status: ServerStatus): void {
    const running = this.runningServers.get(id);
    if (running) running.status = status;
    this.emit('status-changed', id, status);
  }

  private handleProcessExit(id: string, code: number | null, signal: string | null): void {
    this.addLogEntry(id, {
      timestamp: new Date(),
      level: code === 0 ? 'info' : 'warn',
      message: `Server exited with code ${code}${signal ? `, signal: ${signal}` : ''}`,
    });

    this.setServerStatus(id, 'stopped');
    this.emit('exit', id, code, signal);
    this.runningServers.delete(id);
  }

  getServerStatus(id: string): ServerStatus {
    const running = this.runningServers.get(id);
    return running?.status ?? 'stopped';
  }

  isRunning(id: string): boolean {
    const status = this.getServerStatus(id);
    return status === 'running' || status === 'starting';
  }

  getRunningServerIds(): string[] {
    return Array.from(this.runningServers.keys());
  }

  async stopAllServers(): Promise<void> {
    const ids = this.getRunningServerIds();
    await Promise.all(ids.map((id) => this.stopServer(id)));
  }
}

export const serverManager = new ServerManager();
